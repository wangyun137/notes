# C语言编译补充（三）

## 警告选项
警告是针对程序结构的诊断信息，程序不一定有错误，而是存在分先或者可能存在错误

### -fsyntax-only
+ 检查程序中的语法错误，但是不产生输出信息

### -w
+ 禁止所有警告信息

### -Wno-import
+ 禁止关于所有`#import`的警告信息

### -pedantic
+ 打开完全服从`ANSI C`标准所需的全部警告诊断，拒绝接受采用了被禁制的语法扩展程序
+ 无论有没有这个选项，符合`ANSI C`标准的程序应该能够被正确编译(虽然极少数程序需要`-ansi`选项),然而，如果没有这个选项，某些`GNU`扩展和传统`C`特性也得到支持，使用这个选项可以拒绝这些程序，**没有理由使用这个选项，它的存在只是为了满足一些书呆子→＿→**
+ 对于替换关键字（以`__`开始和结束）`pedantic`不会产生警告信息，也不警告跟在`__extension__`后面的表达式，**不过只应该在系统头文件中使用这种转移措施，应用程序最好避免**

### -pedantic-errors
该选项和`-pedantic`类似，但是现实错误而不是警告

### -W
对下列事件显示额外的警告信息：
+ 非易变自动变量(`nonvolatile automatic variable`)可能在调用`longjmp`时发生改变，这些警告仅在优化编译时发生，编译器只知道对`setjmp`的调用，他不可能知道会在哪里调用`longjmp`,事实上一个信号处理例程可以在任何地点调用，其结果是，及时程序没有问题，你也可能得到警告，因为无法在可能出现问题的地方调用`longjmp`
+ 既可以返回值，也可以不返回值的函数（缺少结尾的函数体被看作是不返回函数值），例如，下面的函数将导致这种警告：
  ```

  foo(a) {
    if (a > 0)
      return a;
  }
  ```
  由于`GNU CC`不知道某些函数永不返回(含有`abort`和`lonjmp`),因此有可能出现虚假警告
+ 表达式语句或逗号表达式的左侧没有产生作用(`side effect`)，如果要防止这种警告，应该把未使用的表达式强制转换为`void`类型，例如，`x[i,j]`会导致警告，而`x[(void)i, j]`就不会
+ 无符号数用`>`或`<=`和０作比较

### -Wimplicit-int
+ 警告没有指定类型的声明

### -Wimplicit-function-declararion
+ 警告在声明之前就使用的函数

### -Wimplicit
+ 同`-Wimplicit-int`和`-Wimplicit-function-declararion`

### -Wmain
+ 如果把`main`函数声明或定义成奇怪的类型，编译器就会发出警告，典型情况下，这个函数用于外部连接，返回`int`值，不需要参数，或指定两个参数

### -Wreturn-type
+ 如果函数定义了返回类型，而默认类型是`int`型，编译器发出警告，同时警告那些不带返回值的`return`语句，如果他们所属的函数并非`void`类型

### -Wunsued
+ 如果某个局部变量除了声明就没再使用，或者声明了静态函数但是没有定义，或者某条语句的运算结果显然没有使用，编译器发出警告

### -Wswitch
+ 如果某条`switch`语句的参数属于枚举类型，但是没有对应的`case`语句使用枚举类型，编译器就发出警告，`default`可以防止这个警告，超出枚举范围的`case`同样会导致这个警告

### -Wcomment
+ 如果注释起始序列`/*`出现再注释中，编译器就发出警告

### -Wtrigraphs
+ 警告任何出现的`trigraph`

### -Wformat
+ 检查对`printf`和`scanf`等函数的调用，确认各个参数类型和格式串中的一致

### -Wchar-subscripts
+ 警告类型是`char`的数组下标，这是常见错误，**程序员经常忘记在某些机器上`char`有符号**

### -Wuninitialized
+ 在初始化之前就使用自动变量
+ 这些警告只可能做优化编译时出现，因为他们需要数据流信息，只有做优化的时候才估算数据流信息，如果不指定`-O`选项，就不会出现这些警告
+ 这些警告仅针对等候分配寄存器的变量.因此不会发生在声明为volatile的变量上面,不会发生在已经 取得地址的变量,或长度不等于1, 2, 4, 8字节的变量.同样也不会发生在结构,联合或数组上面,即使他们在 寄存器中
+ 注意,如果某个变量只计算了一个从未使用过的值,这里可能不会警告.因为在显示警告之前,这样的计算已经被 数据流分析删除了
+ 这些警告作为可选项是因为GNU CC还没有智能到判别所有的情况,知道有些看上去错误的代码其实是正确的.下面是 一个这样的例子：
  ```

  int x;
  switch (y)
    {
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    }
  foo (x);
  ```
  如果y始终是1, 2或3,那么x总会被初始化,但是GNU CC不知道这一点
  下面是另一个普遍案例：
  ```
  int save_y;
  if (change_y) save_y = y, y = new_y;
  ...
  if (change_y) y = save_y;
  ```
  这里没有错误,因为只有设置了save_y才使用他
  把所有不返回的函数定义为volatile可以避免某些似是而非的警告

### -Wparenttheses
+ 在某些情况下如果忽略了括号,编译器就发出警告

### -Wtemplate-debugging
+ 当在C++程序中使用`template`的时候,如果调试(`debugging`)没有完全生效,编译器就发出警告. (仅用于C++)

### -Wall
+ 结合所有上述的`-W`选项

**剩下的`-W...`选项不包括在`-Wall`中，因为我们认为在必要情况下，这些被编译器警告的程序结构，可以用在“干净的”程序中**

### -Wtraditional
+ 如果某些程序结构在传统的`C`中的表现和`ANSI C`不同，编译器就发出警告
+ 宏参出现再宏体的字符串常量内部，传统`C`会替换宏惨，而`ANSI C`则视其为常量的一部分
+ 某个函数在块(`block`)中声明为外部，但在块结束后才调用
+ `switch`语句的操作术类型是`long`

### -Wshadow
+ 一旦某个局部变量屏蔽了另一个局部变量，编译器就会发出警告

### -Wid-clash-len
+ 一旦两个确定的标识符具有相同的前`len`个字符，编译器就会发出警告

### -Wpointer-arith
+ 任何语句如果依赖于函数类型的大小或者`void`类型的大小，编译器就发出警告，`GNU C`为了便于计算`void *`和函数指针，就把这些类型的大小定义为`1`

### -Wcast-qual
+ 一旦某个指针强制类型转换以便一出类型修饰符时，编译器发出警告，例如，如果把`const char *`强制转换为`char *`时，警告出现

### -Wcase-align
+ 一旦某个指针类型强制转换时，导致目标所需的地址对齐(`alignment`)增加，编译器就发出警告，例如，某些机器上只能在`2`或`4`字节边界上访问整数，如果在这种机型上把`char *`强制转换成`int *`类型，编译器发出警告

### -Wwrite-strings
+ 规定字符串常量的类型是`const char[length]`,因此,把这样的地址复制给 `non-const char *`指针将产生警告.这些警告能够帮助你在编译期间发现企图写入字符串常量的代码,但是你必须非常仔细的在声明和原形中使用`const`,否则他们只能带来麻烦;所以我们没有让 `-Wall`提供这些警告

### -Wconversation
+ 如果某函数原型导致的类型转换，编译器就发出警告，这里包括定点数和浮点数的互相转换，改变定点数的宽度或符号，除非他们和缺省声明相同

### -Waggregate-return
+ 如果定义或调用了返回结构或联合的函数，编译器就发出警告

### -Wstrict-prototypes
+ 如果函数的声明或定义没有指出参数类型，编译器就发出警告（如果函数的前向引用说明指出了参数类型,则允许后面 使用旧式风格的函数定义,而不会产生警告.）

### -Wmissing-prototypes
+ 如果没有预先声明函数原型就定义了全局函数，编译器就发出警告，即使函数定义自身提供了函数原形也会产生这个警告. 他的目的是检查没有在头文件中声明的全局函数

### -Wmissing-declarations
+ 如果没有预先声明就定义了全局函数,编译器就发出警告.即使函数定义自身提供了函数原形也会产生这个警告.这个选项 的目的是检查没有在头文件中声明的全局函数

### -Wredundant-decls
+ 如果在同一个可见域某定义多次声明,编译器就发出警告,即使这些重复声明有效并且毫无差别

### -Wnested-externs
+ 如果某extern声明出现在函数内部,编译器就发出警告

### Wenum-clash
+ 对于不同枚举类型之间的转换发出警告(仅适用于C++)

### -Wlong-long
+ 如果使用了long long 类型就发出警告.该警告是缺省项.使用`-Wno-long-long`选项能够防止这个警告. `-Wlong-long`和`-Wno-long-long`仅在 `-pedantic`之下才起作用

### -Woverloaded-virtual
+ （仅适用于C++.）在继承类中,虚函数的定义必须匹配虚函数在基类中声明的类型特征(type signature).当继承类声明了某个函数,它可能是个错误的尝试企图定义一个虚函数,使用这个选项能够产生警告:就是说,当某个函数和基类 中的虚函数同名,但是类型特征不符合基类的任何虚函数,编译器将发出警告.

### -Winline
+ 如果某函数不能内嵌(`inline`),无论是声明为`inline`或者是指定了`-finline-functions` 选项,编译器都将发出警告

### -Werror
+ 视警告为错误;出现任何警告即放弃编译
